"""
Reorder alerts API endpoints for automatic low-stock alerting.

Provides REST API for managing reorder alerts and thresholds:
- GET /api/v1/reorder-alerts/ - List active alerts with filters
- GET /api/v1/reorder-alerts/history - View historical alerts
- GET /api/v1/reorder-alerts/{alert_id} - Get single alert
- POST /api/v1/reorder-alerts/{alert_id}/dismiss - Dismiss alert
- POST /api/v1/reorder-alerts/{alert_id}/mark-ordered - Mark as ordered
- PUT /api/v1/reorder-alerts/thresholds/{component_id}/{location_id} - Update threshold
- POST /api/v1/reorder-alerts/thresholds/bulk - Bulk threshold updates
- GET /api/v1/reorder-alerts/reports/low-stock - Low stock report
- GET /api/v1/reorder-alerts/reports/statistics - Alert statistics

Alerts are automatically generated by SQLite database triggers when stock
falls below configured thresholds. These endpoints provide lifecycle management
and reporting capabilities.
"""

from uuid import UUID

from fastapi import APIRouter, Depends, Query, status
from sqlalchemy.orm import Session

from ..auth.dependencies import require_admin
from ..database import get_db
from ..schemas.reorder_alerts import (
    AlertListResponse,
    AlertStatistics,
    AlertUpdateRequest,
    BulkThresholdUpdateRequest,
    BulkThresholdUpdateResponse,
    LowStockReportResponse,
    ReorderAlertResponse,
    ThresholdUpdateRequest,
    ThresholdUpdateResponse,
)
from ..services.reorder_service import ReorderService

router = APIRouter(prefix="/api/v1/reorder-alerts", tags=["Reorder Alerts"])


# ==================== Alert Retrieval ====================


@router.get(
    "/",
    response_model=AlertListResponse,
    status_code=status.HTTP_200_OK,
)
async def list_active_alerts(
    component_id: UUID | None = Query(None, description="Filter by component UUID"),
    location_id: UUID | None = Query(
        None, description="Filter by storage location UUID"
    ),
    min_shortage: int | None = Query(
        None, ge=0, description="Minimum shortage amount to include"
    ),
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> AlertListResponse:
    """
    List all active reorder alerts with optional filters.

    Returns alerts that are currently active (not dismissed, ordered, or resolved).
    Results are ordered by shortage amount descending (most critical first).

    Admin-only operation.

    Args:
        component_id: Optional component UUID filter
        location_id: Optional storage location UUID filter
        min_shortage: Optional minimum shortage filter
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        AlertListResponse with list of active alerts and total count

    Raises:
        HTTPException 403: User is not admin
    """
    service = ReorderService(db)
    alerts = service.get_active_alerts(
        component_id=str(component_id) if component_id else None,
        location_id=str(location_id) if location_id else None,
        min_shortage=min_shortage,
    )
    return AlertListResponse(alerts=alerts, total_count=len(alerts))


@router.get(
    "/history",
    response_model=AlertListResponse,
    status_code=status.HTTP_200_OK,
)
async def get_alert_history(
    component_id: UUID | None = Query(None, description="Filter by component UUID"),
    limit: int = Query(50, ge=1, le=500, description="Maximum number of records"),
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> AlertListResponse:
    """
    Retrieve historical reorder alerts (dismissed, ordered, resolved).

    Returns alerts that have been dismissed, marked as ordered, or auto-resolved
    by restocking. Results are ordered by updated_at descending (newest first).

    Admin-only operation.

    Args:
        component_id: Optional component UUID filter
        limit: Maximum number of records (default 50, max 500)
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        AlertListResponse with list of historical alerts and total count

    Raises:
        HTTPException 403: User is not admin
    """
    service = ReorderService(db)
    alerts = service.get_alert_history(
        component_id=str(component_id) if component_id else None,
        limit=limit,
    )
    return AlertListResponse(alerts=alerts, total_count=len(alerts))


@router.get(
    "/{alert_id}",
    response_model=ReorderAlertResponse,
    status_code=status.HTTP_200_OK,
)
async def get_alert(
    alert_id: int,
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> ReorderAlertResponse:
    """
    Retrieve a single reorder alert by ID.

    Returns full alert details including component/location information,
    shortage metrics, workflow timestamps, and calculated severity.

    Admin-only operation.

    Args:
        alert_id: Alert primary key ID
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        ReorderAlertResponse with full alert details

    Raises:
        HTTPException 403: User is not admin
        HTTPException 404: Alert not found
    """
    service = ReorderService(db)
    alert = service.get_alert_by_id(alert_id)
    return ReorderAlertResponse(**alert)


# ==================== Alert Lifecycle ====================


@router.post(
    "/{alert_id}/dismiss",
    response_model=ReorderAlertResponse,
    status_code=status.HTTP_200_OK,
)
async def dismiss_alert(
    alert_id: int,
    request: AlertUpdateRequest,
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> ReorderAlertResponse:
    """
    Dismiss an active reorder alert.

    Marks the alert as dismissed with optional notes explaining why.
    Use this when:
    - Component is being phased out
    - Manual reorder decision made via other channels
    - Alert is no longer relevant

    Admin-only operation. Only active alerts can be dismissed.

    Args:
        alert_id: Alert ID to dismiss
        request: Optional notes explaining dismissal reason
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        ReorderAlertResponse with updated alert status

    Raises:
        HTTPException 400: Alert is not active
        HTTPException 403: User is not admin
        HTTPException 404: Alert not found
    """
    service = ReorderService(db)
    alert = service.dismiss_alert(alert_id, notes=request.notes)
    return ReorderAlertResponse(**alert)


@router.post(
    "/{alert_id}/mark-ordered",
    response_model=ReorderAlertResponse,
    status_code=status.HTTP_200_OK,
)
async def mark_alert_ordered(
    alert_id: int,
    request: AlertUpdateRequest,
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> ReorderAlertResponse:
    """
    Mark an active alert as ordered (restock order placed with supplier).

    Use optional notes to record:
    - Purchase order number
    - Supplier name
    - Expected delivery date
    - Order quantity

    Admin-only operation. Only active alerts can be marked as ordered.

    Args:
        alert_id: Alert ID to mark as ordered
        request: Optional notes with order details
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        ReorderAlertResponse with updated alert status

    Raises:
        HTTPException 400: Alert is not active
        HTTPException 403: User is not admin
        HTTPException 404: Alert not found
    """
    service = ReorderService(db)
    alert = service.mark_alert_ordered(alert_id, notes=request.notes)
    return ReorderAlertResponse(**alert)


# ==================== Threshold Management ====================


@router.put(
    "/thresholds/{component_id}/{location_id}",
    response_model=ThresholdUpdateResponse,
    status_code=status.HTTP_200_OK,
)
async def update_reorder_threshold(
    component_id: UUID,
    location_id: UUID,
    request: ThresholdUpdateRequest,
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> ThresholdUpdateResponse:
    """
    Update reorder threshold for a component at a specific location.

    Configures automatic reorder alerting. When enabled and stock falls below
    threshold, SQLite triggers automatically create alerts.

    Uses pessimistic locking to prevent concurrent threshold modifications.

    Admin-only operation.

    Args:
        component_id: Component UUID
        location_id: Storage location UUID
        request: Threshold value and enabled status
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        ThresholdUpdateResponse with current configuration and stock status

    Raises:
        HTTPException 400: Invalid threshold value (must be >= 0)
        HTTPException 403: User is not admin
        HTTPException 404: ComponentLocation not found
        HTTPException 409: Concurrent modification (lock timeout)
    """
    service = ReorderService(db)
    result = service.update_reorder_threshold(
        component_id=str(component_id),
        location_id=str(location_id),
        threshold=request.threshold,
        enabled=request.enabled,
    )
    return ThresholdUpdateResponse(**result)


@router.post(
    "/thresholds/bulk",
    response_model=BulkThresholdUpdateResponse,
    status_code=status.HTTP_200_OK,
)
async def bulk_update_thresholds(
    request: BulkThresholdUpdateRequest,
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> BulkThresholdUpdateResponse:
    """
    Bulk update reorder thresholds across multiple component locations.

    Allows batch configuration of reorder monitoring. Failed updates are
    reported individually without affecting successful updates.

    Admin-only operation.

    Args:
        request: List of threshold updates to apply
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        BulkThresholdUpdateResponse with success count and error details

    Raises:
        HTTPException 403: User is not admin
    """
    service = ReorderService(db)
    result = service.bulk_update_thresholds(request.updates)
    return BulkThresholdUpdateResponse(**result)


# ==================== Reports ====================


@router.get(
    "/reports/low-stock",
    response_model=LowStockReportResponse,
    status_code=status.HTTP_200_OK,
)
async def get_low_stock_report(
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> LowStockReportResponse:
    """
    Get real-time low stock report.

    Returns all component locations where reorder monitoring is enabled
    and current stock is below threshold. This provides current state
    independent of alert status.

    Results are ordered by shortage amount descending (most critical first).

    Admin-only operation.

    Args:
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        LowStockReportResponse with list of low stock items

    Raises:
        HTTPException 403: User is not admin
    """
    service = ReorderService(db)
    items = service.check_low_stock()
    return LowStockReportResponse(items=items, total_count=len(items))


@router.get(
    "/reports/statistics",
    response_model=AlertStatistics,
    status_code=status.HTTP_200_OK,
)
async def get_alert_statistics(
    db: Session = Depends(get_db),
    admin: dict = Depends(require_admin),
) -> AlertStatistics:
    """
    Get aggregate alert statistics.

    Provides summary metrics including:
    - Alert counts by status (active, dismissed, ordered, resolved)
    - Active alert statistics (count, average shortage, max shortage)

    Useful for dashboard widgets and monitoring overall inventory health.

    Admin-only operation.

    Args:
        db: Database session (injected)
        admin: Current admin user (injected)

    Returns:
        AlertStatistics with aggregate metrics

    Raises:
        HTTPException 403: User is not admin
    """
    service = ReorderService(db)
    stats = service.get_alert_statistics()
    return AlertStatistics(**stats)
